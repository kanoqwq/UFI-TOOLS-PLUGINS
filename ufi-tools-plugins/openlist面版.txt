
//<script>
(() => {
    /**
     * Toastæ¶ˆæ¯ç®¡ç†å™¨
     */
    const ToastManager = {
        currentToast: null,
        
        // æ¸…é™¤å½“å‰toastï¼ˆé¿å…é‡å¤æç¤ºï¼‰
        clear: () => {
            if (ToastManager.currentToast) {
                ToastManager.currentToast.remove();
                ToastManager.currentToast = null;
            }
        },
        
        success: (message, duration = 3000) => {
            ToastManager.clear();
            ToastManager.currentToast = createToast(message, 'green', duration);
        },
        error: (message, duration = 5000) => {
            ToastManager.clear();
            ToastManager.currentToast = createToast(message, 'red', duration);
        },
        warning: (message, duration = 4000) => {
            ToastManager.clear();
            ToastManager.currentToast = createToast(message, 'orange', duration);
        },
        info: (message, duration = 3000) => {
            ToastManager.clear();
            ToastManager.currentToast = createToast(message, 'blue', duration);
        },
        loading: (message) => {
            ToastManager.clear(); // æ¸…é™¤ä¹‹å‰çš„loading
            ToastManager.currentToast = createToast(`â³ ${message}`, 'blue', 2000);
        }
    }

    /**
     * æ£€æŸ¥é«˜çº§åŠŸèƒ½æ˜¯å¦å¼€å¯
     */
    const checkAdvanceFunc = async () => {
        const res = await runShellWithRoot('whoami')
        if (res.content && res.content.includes('root')) {
            return true
        }
        return false
    }

    /**
     * éªŒè¯é«˜çº§åŠŸèƒ½æƒé™
     */
    const validateAdvancedPermission = async () => {
        if (!(await checkAdvanceFunc())) {
            ToastManager.error("æ²¡æœ‰å¼€å¯é«˜çº§åŠŸèƒ½ï¼Œæ— æ³•ä½¿ç”¨ï¼")
            return false
        }
        return true
    }

    //  è·¯å¾„é…ç½®ç»Ÿä¸€ç®¡ç†
    const OPENLIST_CONFIG = {
        // ä¸»å®‰è£…ç›®å½•ï¼ˆç»Ÿä¸€ä½¿ç”¨/data/openlistä½œä¸ºä¸»ç›®å½•ï¼‰
        INSTALL_DIR: "/data/openlist",
        
        // æ ¸å¿ƒæ–‡ä»¶è·¯å¾„
        get BINARY_PATH() { return `${this.INSTALL_DIR}/openlist`; },
        get OUTPUT_LOG() { return `${this.INSTALL_DIR}/openlist_output.log`; },
        get PID_FILE() { return `${this.INSTALL_DIR}/openlist.pid`; },
        get PASSWORD_FILE() { return `${this.INSTALL_DIR}/password.txt`; },
        
        // å…¬å…±è®¿é—®è·¯å¾„
        PUBLIC_PASSWORD_FILE: "/storage/emulated/0/openlist_password.txt",
        
        // ç³»ç»Ÿé…ç½®è·¯å¾„
        BOOT_SCRIPT_PATH: "/sdcard/ufi_tools_boot.sh",
        
        // ä¸‹è½½é…ç½®
        DOWNLOAD_URL: "https://pan.kanokano.cn/d/UFI-TOOLS-UPDATE/plugins/openlist-android-arm64.tar.gz",
        TEMP_DOWNLOAD_PATH: "/data/openlist_download.tar.gz",
        TEMP_EXTRACT_DIR: "/data/openlist_temp",
        
        // æœåŠ¡é…ç½®
        DEFAULT_PORT: 5244,
        WEB_URL: "http://192.168.0.1:5244/"
    };

    let openlistProcessId = null;
    let extractedPassword = null;

    // æ£€æŸ¥æœåŠ¡æ˜¯å¦è¿è¡Œ
    async function isServiceRunning() {
        // æ£€æŸ¥1: é€šè¿‡PIDæ–‡ä»¶
        const pidRes = await runShellWithRoot(`cat ${OPENLIST_CONFIG.PID_FILE} 2>/dev/null`);
        if (pidRes.success && pidRes.content) {
            const pid = pidRes.content.trim();
            const psRes = await runShellWithRoot(`ps | grep ${pid}`);
            if (psRes.success && psRes.content.includes(pid)) {
                return {running: true, pid};
            }
        }
        
        // æ£€æŸ¥2: é€šè¿‡è¿›ç¨‹å
        const processRes = await runShellWithRoot(`ps | grep '${OPENLIST_CONFIG.BINARY_PATH} server'`);
        if (processRes.success && processRes.content.includes("openlist server")) {
            const pidMatch = processRes.content.match(/^\s*(\d+)/);
            if (pidMatch) {
                return {running: true, pid: pidMatch[1]};
            }
            return {running: true, pid: "unknown"};
        }
        
        return {running: false};
    }

    /**
     * å¯åŠ¨Openlistçš„æ ¸å¿ƒé€»è¾‘ - ä¼˜åŒ–ç‰ˆ
     */
    const startOpenlist = async () => {
        // æƒé™éªŒè¯
        if (!(await validateAdvancedPermission())) {
            return
        }

        ToastManager.loading("æ­£åœ¨å¯åŠ¨ Openlist æœåŠ¡...");
        
        try {
            // æ­¥éª¤1: é¢„æ£€æŸ¥ï¼ˆåˆå¹¶æ£€æŸ¥é€»è¾‘ï¼‰
            const {running, pid} = await isServiceRunning();
            if (running) {
                ToastManager.warning(`âš ï¸ æœåŠ¡å·²åœ¨è¿è¡Œ (PID: ${pid})`);
                return;
            }
            
            // æ­¥éª¤2: ç¯å¢ƒå‡†å¤‡ï¼ˆåˆå¹¶æ£€æŸ¥å’Œæƒé™è®¾ç½®ï¼‰
            const prepareRes = await runShellWithRoot(`
                # æ£€æŸ¥å®‰è£…æ–‡ä»¶
                if [ ! -f "${OPENLIST_CONFIG.BINARY_PATH}" ]; then
                    echo "NOT_INSTALLED"
                    exit 1
                fi
                
                # å‡†å¤‡ç¯å¢ƒ
                mkdir -p ${OPENLIST_CONFIG.INSTALL_DIR}
                chmod 777 ${OPENLIST_CONFIG.INSTALL_DIR}
                chmod 777 ${OPENLIST_CONFIG.BINARY_PATH}
                echo "READY"
            `);
            
            if (!prepareRes.success || prepareRes.content.includes("NOT_INSTALLED")) {
                ToastManager.error("âŒ Openlist æœªå®‰è£…ï¼Œè¯·å…ˆç‚¹å‡»å®‰è£…æŒ‰é’®");
                return;
            }
            
            // æ­¥éª¤3: å¯åŠ¨æœåŠ¡å¹¶è®¾ç½®è‡ªå¯åŠ¨ï¼ˆåˆå¹¶æ“ä½œï¼‰
            ToastManager.loading("å¯åŠ¨æœåŠ¡å¹¶é…ç½®è‡ªå¯åŠ¨...");
            const startCmd = `cd ${OPENLIST_CONFIG.INSTALL_DIR} && nohup ./openlist server > ${OPENLIST_CONFIG.OUTPUT_LOG} 2>&1 &`;
            const startRes = await runShellWithRoot(`
                cd ${OPENLIST_CONFIG.INSTALL_DIR}
                nohup ./openlist server > ${OPENLIST_CONFIG.OUTPUT_LOG} 2>&1 &
                echo $! > ${OPENLIST_CONFIG.PID_FILE}
                
                # åŒæ—¶è®¾ç½®è‡ªå¯åŠ¨
                touch ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                chmod 777 ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                sed -i "/openlist server/d" ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                echo "${startCmd}" >> ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                
                echo "SERVICE_STARTED"
            `);
            
            if (!startRes.success) {
                ToastManager.error(`âŒ æœåŠ¡å¯åŠ¨å¤±è´¥: ${startRes.content}`);
                return;
            }
            
            // è·å–è¿›ç¨‹ID
            const pidRes = await runShellWithRoot(`cat ${OPENLIST_CONFIG.PID_FILE}`);
            if (pidRes.success && pidRes.content) {
                openlistProcessId = pidRes.content.trim();
            }
            
            // æ­¥éª¤4: ç­‰å¾…æœåŠ¡åˆå§‹åŒ–å¹¶æå–å¯†ç ï¼ˆä¼˜åŒ–ç­‰å¾…é€»è¾‘ï¼‰
            ToastManager.loading("ç­‰å¾…æœåŠ¡åˆå§‹åŒ–...");
            let serviceStarted = false;
            let passwordFound = false;
            
            // å‡å°‘é‡è¯•æ¬¡æ•°ï¼Œä¼˜åŒ–ç­‰å¾…æ—¶é—´
            for (let attempt = 1; attempt <= 3; attempt++) {
                await new Promise(resolve => setTimeout(resolve, 2500)); // å‡å°‘ç­‰å¾…æ—¶é—´
                
                const {running} = await isServiceRunning();
                if (running) {
                    serviceStarted = true;
                    
                    // åŒæ—¶å°è¯•æå–å¯†ç 
                    const outputRes = await runShellWithRoot(`cat ${OPENLIST_CONFIG.OUTPUT_LOG}`);
                    if (outputRes.success && outputRes.content) {
                        const passwordRegex = /(?:Successfully created the admin user and the initial password is:|initial password is:)\s*(\S+)/;
                        const match = outputRes.content.match(passwordRegex);
                        
                        if (match && match[1]) {
                            extractedPassword = match[1];
                            passwordFound = true;
                            
                            // ä¿å­˜å¯†ç 
                            await runShellWithRoot(`
                                echo "Openlist åˆå§‹å¯†ç : ${extractedPassword}" > ${OPENLIST_CONFIG.PASSWORD_FILE}
                                echo "Openlist åˆå§‹å¯†ç : ${extractedPassword}" > ${OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE}
                            `);
                            break;
                        }
                    }
                }
            }
            
            // ç»Ÿä¸€çš„ç»“æœå¤„ç†
            if (!serviceStarted) {
                ToastManager.error("âŒ æœåŠ¡å¯åŠ¨å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ—¥å¿—");
                const logRes = await runShellWithRoot(`tail -n 20 ${OPENLIST_CONFIG.OUTPUT_LOG}`);
                if (logRes.success) {
                    createToast(
                        `<div style="width:300px;text-align:left">
                            é”™è¯¯æ—¥å¿—:<br />
                            <pre style="color:red">${logRes.content}</pre>
                        </div>`, 
                        'red', 
                        8000
                    );
                }
                return;
            }
            
            // æˆåŠŸå¯åŠ¨çš„ç»Ÿä¸€æç¤º
            if (passwordFound) {
                ToastManager.success(
                    `ğŸ‰ Openlistå¯åŠ¨æˆåŠŸï¼<br />` +
                    `<a href="${OPENLIST_CONFIG.WEB_URL}" target="_blank">${OPENLIST_CONFIG.WEB_URL}</a><br />` +
                    `åˆå§‹å¯†ç : ${extractedPassword}`,
                    15000
                );
            } else {
                ToastManager.success(
                    `âœ… Openlistå¯åŠ¨æˆåŠŸï¼<br />` +
                    `<a href="${OPENLIST_CONFIG.WEB_URL}" target="_blank">${OPENLIST_CONFIG.WEB_URL}</a><br />` +
                    `è¯·ä½¿ç”¨æŸ¥çœ‹å¯†ç æŒ‰é’®è·å–ç™»å½•å¯†ç `,
                    10000
                );
            }
            
        } catch (error) {
            ToastManager.error(`âŒ å¯åŠ¨è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message || error}`);
        }
    }

    // åˆ›å»ºæŒ‰é’®å…ƒç´ 
    const btn_install_openlist = document.createElement('button');
    btn_install_openlist.textContent = 'ğŸ“¦ å®‰è£… Openlist';
    btn_install_openlist.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    const btn_uninstall_openlist = document.createElement('button');
    btn_uninstall_openlist.textContent = 'ğŸ—‘ï¸ å¸è½½ Openlist';
    btn_uninstall_openlist.style.cssText = 'background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    const btn_start_openlist = document.createElement('button');
    btn_start_openlist.textContent = 'â–¶ï¸ å¯åŠ¨ Openlist';
    btn_start_openlist.style.cssText = 'background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    const btn_stop_openlist = document.createElement('button');
    btn_stop_openlist.textContent = 'â¹ï¸ åœæ­¢ Openlist';
    btn_stop_openlist.style.cssText = 'background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    const btn_view_password = document.createElement('button');
    btn_view_password.textContent = 'ğŸ”‘ æŸ¥çœ‹å¯†ç ';
    btn_view_password.style.cssText = 'background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    const btn_open_web = document.createElement('button');
    btn_open_web.textContent = 'ğŸŒ æ‰“å¼€ç½‘é¡µ';
    btn_open_web.style.cssText = 'background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); color: #333; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.3s ease;';
    
    let disabled_btn_install = false;
    let uninstall_click_count = 0;
    let uninstall_timer = null;

         /**
          * åœæ­¢Openlist
          */
         const stopOpenlist = async () => {
             // æƒé™éªŒè¯
             if (!(await validateAdvancedPermission())) {
                 return
             }

             ToastManager.loading("æ­£åœ¨åœæ­¢ Openlist æœåŠ¡...");
             
             try {
                 // åˆå¹¶æ‰€æœ‰åœæ­¢æ“ä½œ
                 const stopRes = await runShellWithRoot(`
                     # æŸ¥æ‰¾å¹¶ç»ˆæ­¢è¿›ç¨‹
                     PIDS=$(ps aux | grep "openlist server" | grep -v grep | awk '{print $2}')
                     PROCESS_KILLED=false
                     
                     if [ -n "$PIDS" ]; then
                         kill -9 $PIDS
                         PROCESS_KILLED=true
                         echo "PROCESS_KILLED"
                     fi
                     
                     # æ¸…ç†æ–‡ä»¶
                     rm -f ${OPENLIST_CONFIG.PID_FILE}
                     
                     # ç§»é™¤å¼€æœºè‡ªå¯
                     if [ -f "${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}" ]; then
                         sed -i "/openlist server/d" ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                         echo "BOOT_REMOVED"
                     fi
                     
                     echo "STOP_COMPLETE"
                 `);
                 
                 // é‡ç½®å…¨å±€å˜é‡
                 openlistProcessId = null;
                 
                 if (stopRes.success && stopRes.content.includes("STOP_COMPLETE")) {
                     if (stopRes.content.includes("PROCESS_KILLED")) {
                         ToastManager.success("âœ… Openlist æœåŠ¡å·²åœæ­¢");
                     } else {
                         ToastManager.success("âœ… æœåŠ¡å·²åœæ­¢ï¼ˆæœªå‘ç°è¿è¡Œä¸­çš„è¿›ç¨‹ï¼‰");
                     }
                 } else {
                     ToastManager.warning("âš ï¸ åœæ­¢æ“ä½œå¯èƒ½æœªå®Œå…¨æˆåŠŸ");
                 }
                 
             } catch (error) {
                 ToastManager.error(`âŒ åœæ­¢æœåŠ¡æ—¶å‘ç”Ÿé”™è¯¯: ${error.message || error}`);
             }
         };

        /**
         * æŸ¥çœ‹å¯†ç 
         */
        const viewPassword = async () => {
            if (!(await validateAdvancedPermission())) {
                return
            }

            // å¦‚æœå·²æœ‰å¯†ç ï¼Œç›´æ¥æ˜¾ç¤º
            if (extractedPassword) {
                showPasswordInfo(extractedPassword, OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE);
                return;
            }
            
            ToastManager.loading("æ­£åœ¨è·å–å¯†ç ...");
            
            try {
                // å°è¯•ä»å¤šä¸ªæ¥æºè·å–å¯†ç 
                const passwordRes = await runShellWithRoot(`
                    # å°è¯•ä»å…¬å¼€æ–‡ä»¶è¯»å–
                    if [ -f "${OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE}" ]; then
                        cat ${OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE}
                        echo "FROM_PUBLIC_FILE"
                    # å°è¯•ä»æ—¥å¿—æ–‡ä»¶è¯»å–
                    elif [ -f "${OPENLIST_CONFIG.OUTPUT_LOG}" ]; then
                        grep -o "initial password is: [^ ]*" ${OPENLIST_CONFIG.OUTPUT_LOG} | tail -1
                        echo "FROM_LOG_FILE"
                    else
                        echo "NO_PASSWORD_FOUND"
                    fi
                `);
                
                if (passwordRes.success && passwordRes.content) {
                    const match = passwordRes.content.match(/(?:Openlist åˆå§‹å¯†ç : |initial password is: )(\S+)/);
                    if (match && match[1]) {
                        extractedPassword = match[1];
                        showPasswordInfo(extractedPassword, OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE);
                    } else if (passwordRes.content.includes("NO_PASSWORD_FOUND")) {
                        ToastManager.error("âŒ æœªæ‰¾åˆ°å¯†ç æ–‡ä»¶ï¼Œè¯·å…ˆå¯åŠ¨æœåŠ¡");
                    } else {
                        ToastManager.error("âŒ å¯†ç æ–‡ä»¶æ ¼å¼é”™è¯¯æˆ–å¯†ç æœªç”Ÿæˆ");
                    }
                } else {
                    ToastManager.error("âŒ æ— æ³•è¯»å–å¯†ç ä¿¡æ¯");
                }
            } catch (error) {
                ToastManager.error(`âŒ è·å–å¯†ç æ—¶å‘ç”Ÿé”™è¯¯: ${error.message || error}`);
            }
        };

        /**
         * å®‰è£…Openlist
         */
        const installOpenlist = async () => {
            if (disabled_btn_install) return;
            disabled_btn_install = true;
            
            // æƒé™éªŒè¯
            if (!(await validateAdvancedPermission())) {
                disabled_btn_install = false;
                return;
            }

            try {
                ToastManager.loading("æ­£åœ¨å®‰è£… Openlistï¼Œè¯·ç¨å€™...");
                
                // æ­¥éª¤1: ç¯å¢ƒæ£€æŸ¥
                ToastManager.loading("æ­¥éª¤1/5: æ£€æŸ¥å®‰è£…ç¯å¢ƒ...");
                const envCheckRes = await runShellWithRoot(`
                    # æ£€æŸ¥curlæ˜¯å¦å­˜åœ¨
                    if [ ! -f "/data/data/com.minikano.f50_sms/files/curl" ]; then
                        echo "CURL_NOT_FOUND"
                        exit 1
                    fi
                    
                    # æ£€æŸ¥ç£ç›˜ç©ºé—´ï¼ˆè‡³å°‘éœ€è¦50MBï¼‰
                    available_space=$(df /data | tail -1 | awk '{print $4}')
                    if [ "$available_space" -lt 51200 ]; then
                        echo "INSUFFICIENT_SPACE"
                        exit 1
                    fi
                    
                    echo "ENV_CHECK_OK"
                `);
                
                if (!envCheckRes.success || !envCheckRes.content.includes("ENV_CHECK_OK")) {
                    if (envCheckRes.content.includes("CURL_NOT_FOUND")) {
                        ToastManager.error("âŒ ç¯å¢ƒæ£€æŸ¥å¤±è´¥: curlå·¥å…·æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿ç³»ç»Ÿå®Œæ•´æ€§");
                    } else if (envCheckRes.content.includes("INSUFFICIENT_SPACE")) {
                        ToastManager.error("âŒ ç¯å¢ƒæ£€æŸ¥å¤±è´¥: ç£ç›˜ç©ºé—´ä¸è¶³ï¼Œè‡³å°‘éœ€è¦50MBå¯ç”¨ç©ºé—´");
                    } else {
                        ToastManager.error(`âŒ ç¯å¢ƒæ£€æŸ¥å¤±è´¥: ${envCheckRes.content}`);
                    }
                    return;
                }
                
                ToastManager.loading("æ­¥éª¤2/5: å¼€å§‹ä¸‹è½½å’Œå®‰è£…...");
                
                // åˆ›å»ºä¸€ä¸ªPromiseæ¥å¤„ç†å®‰è£…è¿‡ç¨‹ï¼ŒåŒæ—¶ç›‘æ§è¿›åº¦
                const installPromise = runShellWithRoot(`
                    echo "STEP_START: åˆ›å»ºå®‰è£…ç›®å½•"
                    # åˆ›å»ºå®‰è£…ç›®å½•
                    mkdir -p ${OPENLIST_CONFIG.INSTALL_DIR}
                    chmod 777 ${OPENLIST_CONFIG.INSTALL_DIR}
                    echo "STEP_COMPLETE: å®‰è£…ç›®å½•åˆ›å»ºå®Œæˆ"
                    
                    echo "STEP_START: å¼€å§‹ä¸‹è½½æ–‡ä»¶"
                    # ä¸‹è½½æ–‡ä»¶
                    cd /data
                    /data/data/com.minikano.f50_sms/files/curl -L ${OPENLIST_CONFIG.DOWNLOAD_URL} -o ${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}
                    if [ $? -ne 0 ]; then
                        echo "DOWNLOAD_FAILED"
                        exit 1
                    fi
                    echo "STEP_COMPLETE: æ–‡ä»¶ä¸‹è½½å®Œæˆ"
                    
                    echo "STEP_START: éªŒè¯ä¸‹è½½æ–‡ä»¶"
                    # éªŒè¯ä¸‹è½½æ–‡ä»¶å®Œæ•´æ€§
                    if [ ! -s "${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}" ]; then
                        echo "DOWNLOAD_EMPTY"
                        exit 1
                    fi
                    
                    # æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼ˆç¡®ä¿æ˜¯gzipå‹ç¼©æ–‡ä»¶ï¼‰
                    file_type=$(file "${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}" 2>/dev/null || echo "unknown")
                    echo "DEBUG_FILE_TYPE: $file_type"
                    
                    # æ›´å®½æ¾çš„æ–‡ä»¶ç±»å‹æ£€æŸ¥ï¼Œæ”¯æŒå¤šç§gzipæ ¼å¼æè¿°
                    type_check_passed=false
                    if echo "$file_type" | grep -i -E "gzip|compressed|tar\.gz|archive" >/dev/null 2>&1; then
                        type_check_passed=true
                    fi
                    
                    # å¦‚æœæ–‡ä»¶ç±»å‹æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•ç›´æ¥éªŒè¯tar.gzæ–‡ä»¶å®Œæ•´æ€§
                    if [ "$type_check_passed" = "false" ]; then
                        echo "WARN_FILE_TYPE: $file_type (å°è¯•ç›´æ¥éªŒè¯tar.gzå®Œæ•´æ€§)"
                        if ! tar -tzf "${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}" >/dev/null 2>&1; then
                            echo "FILE_TYPE_ERROR: $file_type (taréªŒè¯ä¹Ÿå¤±è´¥)"
                            exit 1
                        else
                            echo "TAR_VERIFY_SUCCESS: æ–‡ä»¶è™½ç„¶ç±»å‹æ£€æµ‹å¼‚å¸¸ä½†taréªŒè¯é€šè¿‡"
                        fi
                    fi
                    echo "STEP_COMPLETE: æ–‡ä»¶éªŒè¯é€šè¿‡"
                    
                    echo "STEP_START: è§£å‹å®‰è£…æ–‡ä»¶"
                    # è§£å‹å’Œå®‰è£…ï¼ˆå¢å¼ºé”™è¯¯å¤„ç†ï¼‰
                    rm -rf ${OPENLIST_CONFIG.TEMP_EXTRACT_DIR}
                    mkdir -p ${OPENLIST_CONFIG.TEMP_EXTRACT_DIR}
                    
                    # ä½¿ç”¨æ›´å¥å£®çš„è§£å‹å‘½ä»¤
                    if ! tar -tzf "${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}" >/dev/null 2>&1; then
                        echo "ARCHIVE_CORRUPTED"
                        exit 1
                    fi
                    
                    tar -xzf "${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}" -C "${OPENLIST_CONFIG.TEMP_EXTRACT_DIR}" 2>/dev/null
                    if [ $? -ne 0 ]; then
                        echo "EXTRACT_FAILED"
                        exit 1
                    fi
                    
                    # éªŒè¯è§£å‹ç»“æœ
                    if [ ! -d "${OPENLIST_CONFIG.TEMP_EXTRACT_DIR}" ] || [ -z "$(ls -A "${OPENLIST_CONFIG.TEMP_EXTRACT_DIR}" 2>/dev/null)" ]; then
                        echo "EXTRACT_EMPTY"
                        exit 1
                    fi
                    echo "STEP_COMPLETE: æ–‡ä»¶è§£å‹å®Œæˆ"
                    
                    echo "STEP_START: å®‰è£…å¯æ‰§è¡Œæ–‡ä»¶"
                    # æŸ¥æ‰¾å¹¶å¤åˆ¶openlistå¯æ‰§è¡Œæ–‡ä»¶
                    openlist_file=$(find ${OPENLIST_CONFIG.TEMP_EXTRACT_DIR} -name "openlist" -type f | head -1)
                    if [ -z "$openlist_file" ]; then
                        echo "OPENLIST_BINARY_NOT_FOUND"
                        exit 1
                    fi
                    
                    cp "$openlist_file" ${OPENLIST_CONFIG.BINARY_PATH}
                    chmod 777 ${OPENLIST_CONFIG.BINARY_PATH}
                    
                    # éªŒè¯å®‰è£…
                    if [ ! -f "${OPENLIST_CONFIG.BINARY_PATH}" ]; then
                        echo "VERIFY_FAILED"
                        exit 1
                    fi
                    echo "STEP_COMPLETE: å¯æ‰§è¡Œæ–‡ä»¶å®‰è£…å®Œæˆ"
                    
                    echo "STEP_START: é…ç½®è‡ªå¯åŠ¨"
                    # è®¾ç½®è‡ªå¯åŠ¨
                    touch ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                    chmod 777 ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                    sed -i "/openlist server/d" ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                    echo "cd ${OPENLIST_CONFIG.INSTALL_DIR} && nohup ./openlist server > ${OPENLIST_CONFIG.OUTPUT_LOG} 2>&1 &" >> ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}
                    echo "STEP_COMPLETE: è‡ªå¯åŠ¨é…ç½®å®Œæˆ"
                    
                    echo "STEP_START: æ¸…ç†ä¸´æ—¶æ–‡ä»¶"
                    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                    rm -rf ${OPENLIST_CONFIG.TEMP_EXTRACT_DIR} ${OPENLIST_CONFIG.TEMP_DOWNLOAD_PATH}
                    echo "STEP_COMPLETE: ä¸´æ—¶æ–‡ä»¶æ¸…ç†å®Œæˆ"
                    
                    echo "INSTALL_SUCCESS"
                `, 120 * 1000);
                
                // å®æ—¶ç›‘æ§å®‰è£…è¿›åº¦
                const progressInterval = setInterval(() => {
                    ToastManager.loading("å®‰è£…è¿›è¡Œä¸­ï¼Œè¯·è€å¿ƒç­‰å¾…...");
                }, 5000);
                
                let installRes;
                try {
                    installRes = await installPromise;
                } finally {
                    clearInterval(progressInterval);
                }
                
                // æ˜¾ç¤ºå®‰è£…è¿›åº¦ä¿¡æ¯
                if (installRes.success && installRes.content) {
                    const steps = installRes.content.match(/STEP_COMPLETE: [^\n]+/g);
                    if (steps && steps.length > 0) {
                        const lastStep = steps[steps.length - 1].replace('STEP_COMPLETE: ', '');
                        ToastManager.loading(`æ­¥éª¤è¿›åº¦: ${lastStep} (${steps.length}/6)`);
                    }
                }
                
                // è¯¦ç»†çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€æ£€æŸ¥
                if (!installRes.success) {
                    const lastStep = installRes.content.match(/STEP_START: ([^\n]+)/g);
                    const failedStep = lastStep ? lastStep[lastStep.length - 1].replace('STEP_START: ', '') : 'æœªçŸ¥æ­¥éª¤';
                    
                    if (installRes.content.includes("DOWNLOAD_FAILED")) {
                        ToastManager.error(`âŒ ä¸‹è½½å¤±è´¥ (æ­¥éª¤: ${failedStep})<br />è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä¸‹è½½åœ°å€æ˜¯å¦å¯ç”¨<br />ä¸‹è½½åœ°å€: ${OPENLIST_CONFIG.DOWNLOAD_URL}`);
                    } else if (installRes.content.includes("DOWNLOAD_EMPTY")) {
                        ToastManager.error(`âŒ ä¸‹è½½æ–‡ä»¶ä¸ºç©º (æ­¥éª¤: ${failedStep})<br />å¯èƒ½ç½‘ç»œä¸­æ–­æˆ–æœåŠ¡å™¨é—®é¢˜ï¼Œè¯·é‡è¯•`);
                    } else if (installRes.content.includes("FILE_TYPE_ERROR")) {
                        const fileTypeMatch = installRes.content.match(/FILE_TYPE_ERROR: (.+)/);
                        const debugTypeMatch = installRes.content.match(/DEBUG_FILE_TYPE: (.+)/);
                        const warnTypeMatch = installRes.content.match(/WARN_FILE_TYPE: (.+)/);
                        const fileType = fileTypeMatch ? fileTypeMatch[1] : 'æœªçŸ¥';
                        const debugType = debugTypeMatch ? debugTypeMatch[1] : '';
                        const warnType = warnTypeMatch ? warnTypeMatch[1] : '';
                        
                        ToastManager.error(
                            `âŒ æ–‡ä»¶æ ¼å¼éªŒè¯å¤±è´¥ (æ­¥éª¤: ${failedStep})<br />` +
                            `æ£€æµ‹åˆ°çš„æ–‡ä»¶ç±»å‹: ${fileType}<br />` +
                            `${debugType ? `è°ƒè¯•ä¿¡æ¯: ${debugType}<br />` : ''}` +
                            `${warnType ? `è­¦å‘Šä¿¡æ¯: ${warnType}<br />` : ''}` +
                            `æœŸæœ›: gzip/tar.gzå‹ç¼©åŒ…<br />` +
                            `å»ºè®®: æ–‡ä»¶å¯èƒ½æŸåï¼Œè¯·é‡æ–°ä¸‹è½½æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥`
                        );
                    } else if (installRes.content.includes("ARCHIVE_CORRUPTED")) {
                        ToastManager.error(`âŒ å‹ç¼©åŒ…æŸå (æ­¥éª¤: ${failedStep})<br />å‹ç¼©åŒ…å·²æŸåæˆ–ä¸å®Œæ•´ï¼Œè¯·é‡æ–°ä¸‹è½½`);
                    } else if (installRes.content.includes("EXTRACT_FAILED")) {
                        ToastManager.error(`âŒ è§£å‹å¤±è´¥ (æ­¥éª¤: ${failedStep})<br />æ–‡ä»¶å¯èƒ½æŸåæˆ–tarå‘½ä»¤ä¸æ”¯æŒè¯¥æ ¼å¼`);
                    } else if (installRes.content.includes("EXTRACT_EMPTY")) {
                        ToastManager.error(`âŒ è§£å‹ç»“æœä¸ºç©º (æ­¥éª¤: ${failedStep})<br />å‹ç¼©åŒ…å†…å®¹å¼‚å¸¸æˆ–è§£å‹è·¯å¾„é—®é¢˜`);
                    } else if (installRes.content.includes("OPENLIST_BINARY_NOT_FOUND")) {
                        ToastManager.error(`âŒ å¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ° (æ­¥éª¤: ${failedStep})<br />å‹ç¼©åŒ…ä¸­ä¸åŒ…å«openlistå¯æ‰§è¡Œæ–‡ä»¶`);
                    } else if (installRes.content.includes("VERIFY_FAILED")) {
                        ToastManager.error(`âŒ å®‰è£…éªŒè¯å¤±è´¥ (æ­¥éª¤: ${failedStep})<br />openlistå¯æ‰§è¡Œæ–‡ä»¶æœªæ‰¾åˆ°æˆ–å¤åˆ¶å¤±è´¥<br />ç›®æ ‡è·¯å¾„: ${OPENLIST_CONFIG.BINARY_PATH}`);
                    } else {
                        ToastManager.error(`âŒ å®‰è£…å¤±è´¥ (æ­¥éª¤: ${failedStep})<br />è¯¦ç»†é”™è¯¯ä¿¡æ¯: ${installRes.content || 'æ— é”™è¯¯è¾“å‡º'}`);
                    }
                    return;
                }
                
                // æˆåŠŸçŠ¶æ€çš„è¯¦ç»†æ£€æŸ¥
                if (installRes.content.includes("INSTALL_SUCCESS")) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶éªŒè¯è­¦å‘Š
                    const tarVerifySuccess = installRes.content.includes("TAR_VERIFY_SUCCESS");
                    const warnTypeMatch = installRes.content.match(/WARN_FILE_TYPE: (.+)/);
                    
                    let successMessage = 
                        `ğŸ‰ Openlist å®‰è£…æˆåŠŸï¼<br />` +
                        `âœ… æ–‡ä»¶å·²ä¸‹è½½å¹¶è§£å‹åˆ°: ${OPENLIST_CONFIG.INSTALL_DIR}<br />` +
                        `âœ… å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„: ${OPENLIST_CONFIG.BINARY_PATH}<br />` +
                        `âœ… è‡ªå¯åŠ¨è„šæœ¬å·²é…ç½®<br />`;
                    
                    if (tarVerifySuccess && warnTypeMatch) {
                        successMessage += `â„¹ï¸ æ³¨æ„: æ–‡ä»¶ç±»å‹æ£€æµ‹å¼‚å¸¸ä½†taréªŒè¯é€šè¿‡<br />`;
                    }
                    
                    successMessage += `ç°åœ¨å¯ä»¥ä½¿ç”¨å¯åŠ¨æŒ‰é’®æ¥å¯åŠ¨æœåŠ¡`;
                    
                    ToastManager.success(successMessage, 10000);
                } else {
                    // æä¾›æ›´è¯¦ç»†çš„è¯Šæ–­ä¿¡æ¯
                    ToastManager.warning(
                        `âš ï¸ å®‰è£…å¯èƒ½æœªå®Œå…¨æˆåŠŸ<br />` +
                        `åŸå› : è„šæœ¬æ‰§è¡Œå®Œæˆä½†æœªæ”¶åˆ°æˆåŠŸæ ‡è¯†<br />` +
                        `è¾“å‡ºå†…å®¹: ${installRes.content || 'æ— è¾“å‡ºå†…å®¹'}<br />` +
                        `å»ºè®®: æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–é‡æ–°å°è¯•å®‰è£…`,
                        8000
                    );
                    
                    // é¢å¤–çš„çŠ¶æ€æ£€æŸ¥
                    ToastManager.loading("æ­£åœ¨æ£€æŸ¥å®‰è£…çŠ¶æ€...");
                    setTimeout(async () => {
                        const checkRes = await runShellWithRoot(`
                            if [ -f "${OPENLIST_CONFIG.BINARY_PATH}" ]; then
                                echo "BINARY_EXISTS"
                                ls -la "${OPENLIST_CONFIG.BINARY_PATH}"
                            else
                                echo "BINARY_NOT_FOUND"
                            fi
                        `);
                        
                        if (checkRes.success && checkRes.content.includes("BINARY_EXISTS")) {
                            ToastManager.info(
                                `â„¹ï¸ æ£€æŸ¥ç»“æœ: openlistå¯æ‰§è¡Œæ–‡ä»¶å·²å­˜åœ¨<br />` +
                                `æ–‡ä»¶ä¿¡æ¯: ${checkRes.content.replace('BINARY_EXISTS', '').trim()}<br />` +
                                `å¯ä»¥å°è¯•å¯åŠ¨æœåŠ¡`,
                                6000
                            );
                        } else {
                            ToastManager.error(
                                `âŒ æ£€æŸ¥ç»“æœ: openlistå¯æ‰§è¡Œæ–‡ä»¶ä¸å­˜åœ¨<br />` +
                                `è·¯å¾„: ${OPENLIST_CONFIG.BINARY_PATH}<br />` +
                                `è¯·é‡æ–°å®‰è£…`,
                                6000
                            );
                        }
                    }, 1000);
                }
                
            } catch (error) {
                ToastManager.error(`âŒ å®‰è£…è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message || error}`);
            } finally {
                disabled_btn_install = false;
            }
        };

        /**
         * å¸è½½Openlistçš„æ ¸å¿ƒé€»è¾‘
         */
        const uninstallOpenlist = async () => {
            // æƒé™éªŒè¯
            if (!(await validateAdvancedPermission())) {
                return;
            }
            
            uninstall_click_count++;
            if (uninstall_click_count < 2) {
                ToastManager.warning("å†ç‚¹ä¸€æ¬¡ç¡®è®¤å¸è½½ Openlist");
                uninstall_timer = setTimeout(() => {
                    uninstall_click_count = 0;
                }, 3000);
                return;
            }
            
            ToastManager.loading("æ­£åœ¨å¸è½½ Openlist...");
            
            try {
                // æ­¥éª¤1: åœæ­¢æœåŠ¡
                await stopOpenlist();
                
                // æ­¥éª¤2: åˆ é™¤æ–‡ä»¶ï¼ˆåŒ…å«ä¸´æ—¶æ–‡ä»¶æ¸…ç†ï¼‰
                const removeRes = await runShellWithRoot(`
                    # åˆ é™¤æ•´ä¸ªå®‰è£…ç›®å½•
                    rm -rf ${OPENLIST_CONFIG.INSTALL_DIR}
                    
                    # åˆ é™¤å…¬å…±å¯†ç æ–‡ä»¶
                    rm -f ${OPENLIST_CONFIG.PUBLIC_PASSWORD_FILE}
                    
                    # æ¸…ç†ä¸´æ—¶ä¸‹è½½æ–‡ä»¶å’Œè§£å‹ç›®å½•ï¼ˆä½¿ç”¨ç»å¯¹è·¯å¾„ï¼‰
                    rm -f /data/openlist_download.tar.gz
                    rm -rf /data/openlist_temp
                    
                    # ç§»é™¤è‡ªå¯åŠ¨é…ç½®
                    sed -i "/openlist server/d" ${OPENLIST_CONFIG.BOOT_SCRIPT_PATH}

		    pkill openlist
                    
                    echo "UNINSTALL_COMPLETE"
                `);
                
                if (removeRes.success && removeRes.content.includes("UNINSTALL_COMPLETE")) {
                    ToastManager.success(
                        `âœ… å¸è½½ Openlist æˆåŠŸï¼<br />` +
                        `å·²åˆ é™¤æ‰€æœ‰ç›¸å…³æ–‡ä»¶ã€é…ç½®å’Œä¸´æ—¶æ–‡ä»¶`
                    );
                } else {
                    ToastManager.error(
                        `âŒ å¸è½½è¿‡ç¨‹ä¸­å‡ºç°é—®é¢˜<br />` +
                        `è¾“å‡º: ${removeRes.content || 'æ— è¾“å‡º'}`
                    );
                }
                
            } catch (error) {
                ToastManager.error(`âŒ å¸è½½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message || error}`);
            } finally {
                uninstall_click_count = 0;
                if (uninstall_timer) {
                    clearTimeout(uninstall_timer);
                    uninstall_timer = null;
                }
            }
        };
        
        // æ˜¾ç¤ºå¯†ç ä¿¡æ¯çš„è¾…åŠ©å‡½æ•°
        function showPasswordInfo(password, path) {
            ToastManager.success(
                `<div style="width:300px;text-align:center">
                    <strong>åˆå§‹å¯†ç :</strong> ${password}<br />
                    <strong>æ–‡ä»¶è·¯å¾„:</strong> ${path}
                </div>`,
                8000
            );
        }

        // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
        btn_start_openlist.onclick = async () => {
            await startOpenlist();
        };
        
        btn_stop_openlist.onclick = async () => {
            await stopOpenlist();
        };
        
        btn_view_password.onclick = viewPassword;
        
        btn_install_openlist.onclick = async () => {
            await installOpenlist();
        };
        
        btn_uninstall_openlist.onclick = async () => {
            await uninstallOpenlist();
        };
        
        btn_open_web.onclick = () => {
            window.open(OPENLIST_CONFIG.WEB_URL, '_blank');
        };

        const openlistContainer = document.querySelector('.functions-container');
        openlistContainer.insertAdjacentHTML("afterend", `
<div id="IFRAME_OPENLIST" style="width: 100%; margin-top: 10px;">
    <div class="title" style="margin: 6px 0 ;">
        <strong>ğŸ“ Openlist æ–‡ä»¶ç®¡ç†</strong>
        <div style="display: inline-block;" id="collapse_openlist_btn"></div>
    </div>
    <div class="collapse" id="collapse_openlist" data-name="close" style="height: 0px; overflow: hidden;">
        <div class="collapse_box">
        <div id="openlist_action_box" style="margin-bottom:10px;display:flex;gap:10px;flex-wrap:wrap"></div>
            <ul class="deviceList">
<li style="padding:10px">
        <iframe id="openlist_iframe" src="${OPENLIST_CONFIG.WEB_URL}" style="border:none;padding:0;margin:0;width:100%;height:500px;border-radius: 10px;overflow: hidden;opacity: .6;"></iframe>
</li> </ul>
        </div>
    </div>
</div>
`);
        
        // æ·»åŠ æŒ‰é’®åˆ°å®¹å™¨
        const openlistBox = document.querySelector('#openlist_action_box');
        
        // ä¸ºæŒ‰é’®æ·»åŠ ç»Ÿä¸€çš„btnç±»
         [btn_install_openlist, btn_uninstall_openlist, btn_start_openlist, btn_stop_openlist, btn_view_password, btn_open_web].forEach(btn => {
             btn.classList.add('btn');
         });
         
         openlistBox.appendChild(btn_install_openlist);
         openlistBox.appendChild(btn_uninstall_openlist);
         openlistBox.appendChild(btn_start_openlist);
         openlistBox.appendChild(btn_stop_openlist);
         openlistBox.appendChild(btn_view_password);
         openlistBox.appendChild(btn_open_web);
        
        // åˆå§‹åŒ–æŠ˜å åŠŸèƒ½
        collapseGen("#collapse_openlist_btn", "#collapse_openlist", "#collapse_openlist", (e) => { });
    })()
//</script>
